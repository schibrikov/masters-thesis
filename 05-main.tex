\section{Основная часть}

Одним из требований к разрабатываемой системе является отсутствие требований к аппаратному обеспечению пользователя. Нейронная сеть для замены лица очень ресурсоемкая, для нормальной работы ей требуется видеокарта с, как минимум, 10 гигабайтами VRAM. Обработка на устройстве пользователя в таком случае сделала бы сервис неудобным или невозможным для использования для многих пользователей, в виду отсутствия полноценной видеокарты на большинстве ноутбуков, смартфонов и других устройств.

Использование устройства пользователя для вычислений так же создало бы проблемы в лицензировании и охране исходных кодов и алгоритмов, так как программу бы пришлось устанавливать на компьютер пользователя.

Данные ограничения не позволяют разработать сервис в виде desktop-приложения.

Значительно лучше в наши требования вписывается клиент-серверная модель. В ней мы можем вынести большую часть системы на сервер, скрывая исполняемый код от пользователя и производя вычисления на собственной инфраструктуре. Для пользователя в таком случае необходимо предоставить лишь "тонкий" клиент, который может работать на любой платформе, в т.ч. на смартфоне или планшете.

В требованиях к системе присутствует "одновременная работа множества пользователей". В зависимости от количества пользователей одновременная их работа в клиент-серверной может потребовать значительных вычислительных мощностей. Соответственно с ростом количества пользователей системы возникает необходимость в увеличении доступных ресурсов. Этот процесс и способность к нему системы называется масштабированием.

Различают горизонтальное и вертикальное масштабирование.
Вертикальное - это простая замена сервера на более мощный. Например, если сервер с 8 процессорными ядрами и 32 гигабайтами памяти перестает справляться с нагрузками, его можно просто заменить на более мощный с, например, 16 ядрами и 64 гигабайтами памяти.
Более гибким считается горизонтальное масштабирование. Вместо увеличения мощности одного узла, оно подразумевает запуск дополнительных узлов, выполняющих одну и ту же роль в системе. В большинстве случаев это требует от масштабируемого компонента отсутствие собственного состояния, которое иначе создает проблему рассинхронизации данных при параллельной работы нескольких экземпляров приложения.

Исходя из необходимости поддержки масштабирования для множества пользователей и ресурсоемкости системы, при разработке изначально было принято решение в необходимости поддержки горизонтального масштабирования системы.

Наиболее важная и ресурсозатратная функция разрабатываемой системы - замена лица. Для поддержки одновременной работы множества пользователей нам необходимо иметь возможность легко масштабировать компонент, выполняющий эту функцию.

Данные размышления приводят нам к архитектуре, состоящей из 4 звеньев - клиент, сервер, база данных и обработчик.

\addimg{architecture_01}{0.6}{Четырехзвенная архитектура}{architecture_scheme}

Данная архитектура позволяет легко дублировать и масштабировать наиболее важные компоненты - сервер приложения и сервера обработчики. При этом в местах соединения одного компонента со многими возникает необходимость в дополнительных узлах, выполняющих функцию распределения нагрузки и распределения соединений с конкретным узлом.

\subsection{Балансировщик нагрузки}

При наличии нескольких серверов приложений требуется балансировщик нагрузки (load balancer) - это дополнительный сервер, который получает запрос от клиента и перенаправляет его в один из целевых серверов приложений. Балансировщик нагрузки равномерно распределяет нагрузку по серверам, а так же позволяет при недоступности одного или нескольких серверов, направлять подключения на те, которые готовы обрабатывать запросы. Балансировщик работает с синхронными запросами по таким протоколам, как HTTP или GRPC. Microsoft Azure, как и другие облачные провайдеры, предоставляет возможность арендовывать готовый к использованию балансировщик.

\subsection{Взаимодействие с обработчиками}

При соединении серверов приложений с серверами обработчиками возникает необходимость во взаимодействии другого вида. При использовании обычного балансировщика нагрузки возникала бы необходимость держать соединение между этими серверами все время обработки запроса, который может занимать до нескольких часов. К тому же балансировщик не позволяет "откладывать" соединения на потом, когда свободных серверов для обработки нет.

Для этого соединения я выбрал распределенную очередь задач. В данной случае вместо балансировщика нагрузки используется брокер сообщений, позволяющий сохранять задачи, требующие обработки, в очереди. Одно из наиболее готовых к использованию "из коробки" решений в этой области - библиотека Celery для Python\cite{celery_website}. Она реализует всю необходимую логику для описания задач на языке программирования, содержит протокол передачи задач и данных через брокер сообщений, а так же имеет адаптары к множеству брокеров, таких как Redis, RabbitMQ или Amazon SQS.

На роль брокера сообщений был выбран RabbitMQ, который в отличие от Redis имеет более полные гарантии сохранности данных, и в отличие от Amazon SQS является решением с открытым исходным кодом, которое можно запустить на собственной инфраструктуре, не привязываясь к конкретному облачному провайдеру.

Минимальный пример использования Celery с RabbitMQ на языке Python может выглядеть так:

Описываем приложение Celery с функцией сложения двух чисел, помеченной декоратором \texttt{@app.task}:

\begin{lstlisting}
    from celery import Celery

    app = Celery('tasks', broker='amqp://guest@localhost//')

    @app.task
    def add(x, y):
        return x + y
\end{lstlisting}

Запустить сервер обработчик Celery можно так \mintinline{bash}{celery -A tasks worker}.

Вызов функции и получение результата:

\begin{lstlisting}
    from tasks import add
    
    result = add.delay(4, 4)
    print(result.get(timeout=1))
\end{lstlisting}

\subsection{Клиентское приложение (фронтенд)}

Одно из преимуществ клиент-серверных архитектур - возможность независимой реализации нескольких клиентов к одному серверу. Это позволяет иметь отдельные приложения для различных платформ, таких как ПК, iOS, Android или WEB. Последняя (WEB) выделяется из этого ряда тем, что может работать на всех остальных. Так, любой сайт можно открыть практически на любом доступном устройстве. Поэтому веб является максимально универсальной платформой и избавляет от необходимости разработки других клиентов. Исходя из этого, в качестве первого (и пока единственного) клиентского приложения для реализации был выбран именно WEB.

На данный момент существует множество подходов и технологий реализации веб-приложений, рассмотрение каждого из которых невозможно в рамках данной работы. Мною для разработки был выбран язык Typescript и фреймворк SvelteKit\cite{sveltekit_website}. Это одна из наиболее передовых комбинаций технологий разработки веб-приложений, из плюсов которой можно отметить поддерживаемость, скорость работы и удобство разработки.

Клиент обращается к серверу по протоколу HTTP, используя JSON в качестве формата сообщений.

\subsection{Сервер приложения (бэкенд)}

Основная задача бэкенда в нашей архитектуре - реализация логики работы с различными сущностями и компонентами системы и предоставления внешнего API для клиентов. В качестве архитектурного стиля для реализации API выбран REST\cite{masse2011rest} на базе JSON и HTTP в качестве протокола передачи данных.

Для создания API была выбрана библиотека FastAPI \cite{fastapi_website}. Для работы с базой данных - библотека SQLAlchemy и Alembic в роли движка миграций.

\subsection{База данных}

Для хранения пользователей, истории запросов, данных о состоянии обработки запросов, информации о подписках и многого другого была выбрана система управления базами данных PostgreSQL.

От других подобных решений она отличается полной бесплатностью и открытым исходным кодом, огромным сообществом, множеством возможностей и дополнений, работой "из коробки" с практически любыми языками и библиотеками. PostgreSQL - стандарт де-факто среди SQL баз данных для веб-приложений.