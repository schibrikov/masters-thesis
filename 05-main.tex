\section{Основная часть}

Одним из требований к разрабатываемой системе является отсутствие требований к аппаратному обеспечению пользователя. Нейронная сеть для замены лица очень ресурсоемкая, для нормальной работы ей требуется видеокарта с, как минимум, 10 гигабайтами VRAM. Обработка на устройстве пользователя в таком случае сделала бы сервис неудобным или невозможным для использования для многих пользователей, в виду отсутствия полноценной видеокарты на большинстве ноутбуков, смартфонов и других устройств.

Использование устройства пользователя для вычислений так же создало бы проблемы в лицензировании и охране исходных кодов и алгоритмов, так как программу бы пришлось устанавливать на компьютер пользователя.

Данные ограничения не позволяют разработать сервис в виде desktop-приложения.

Значительно лучше в наши требования вписывается клиент-серверная модель. В ней мы можем вынести большую часть системы на сервер, скрывая исполняемый код от пользователя и производя вычисления на собственной инфраструктуре. Для пользователя в таком случае необходимо предоставить лишь "тонкий" клиент, который может работать на любой платформе, в т.ч. на смартфоне или планшете.

В требованиях к системе присутствует "одновременная работа множества пользователей". В зависимости от количества пользователей одновременная их работа в клиент-серверной может потребовать значительных вычислительных мощностей. Соответственно с ростом количества пользователей системы возникает необходимость в увеличении доступных ресурсов. Этот процесс и способность к нему системы называется масштабированием.

Различают горизонтальное и вертикальное масштабирование.
Вертикальное - это простая замена сервера на более мощный. Например, если сервер с 8 процессорными ядрами и 32 гигабайтами памяти перестает справляться с нагрузками, его можно просто заменить на более мощный с, например, 16 ядрами и 64 гигабайтами памяти.
Более гибким считается горизонтальное масштабирование. Вместо увеличения мощности одного узла, оно подразумевает запуск дополнительных узлов, выполняющих одну и ту же роль в системе. В большинстве случаев это требует от масштабируемого компонента отсутствие собственного состояния, которое иначе создает проблему рассинхронизации данных при параллельной работы нескольких экземпляров приложения.

Исходя из необходимости поддержки масштабирования для множества пользователей и ресурсоемкости системы, при разработке изначально было принято решение в необходимости поддержки горизонтального масштабирования системы.

Наиболее важная и ресурсозатратная функция разрабатываемой системы - замена лица. Для поддержки одновременной работы множества пользователей нам необходимо иметь возможность легко масштабировать компонент, выполняющий эту функцию.

Данные размышления приводят нам к архитектуре, состоящей из 4 звеньев - клиент, сервер, база данных и обработчик.

\addimg{architecture_01}{0.6}{Четырехзвенная архитектура}{architecture_scheme}

Данная архитектура позволяет легко дублировать и масштабировать наиболее важные компоненты - сервер приложения и сервера обработчики. При этом в местах соединения одного компонента со многими возникает необходимость в дополнительных узлах, выполняющих функцию распределения нагрузки и распределения соединений с конкретным узлом.

\subsection{Балансировщик нагрузки}

При наличии нескольких серверов приложений требуется балансировщик нагрузки (load balancer) - это дополнительный сервер, который получает запрос от клиента и перенаправляет его в один из целевых серверов приложений. Балансировщик нагрузки равномерно распределяет нагрузку по серверам, а так же позволяет при недоступности одного или нескольких серверов, направлять подключения на те, которые готовы обрабатывать запросы. Балансировщик работает с синхронными запросами по таким протоколам, как HTTP или GRPC. Microsoft Azure, как и другие облачные провайдеры, предоставляет возможность арендовывать готовый к использованию балансировщик.

\subsection{Взаимодействие с обработчиками}

При соединении серверов приложений с серверами обработчиками возникает необходимость во взаимодействии другого вида. При использовании обычного балансировщика нагрузки возникала бы необходимость держать соединение между этими серверами все время обработки запроса, который может занимать до нескольких часов. К тому же балансировщик не позволяет "откладывать" соединения на потом, когда свободных серверов для обработки нет.

Для этого соединения я выбрал распределенную очередь задач. В данной случае вместо балансировщика нагрузки используется брокер сообщений, позволяющий сохранять задачи, требующие обработки, в очереди. Одно из наиболее готовых к использованию "из коробки" решений в этой области - библиотека Celery для Python\cite{celery_website}. Она реализует всю необходимую логику для описания задач на языке программирования, содержит протокол передачи задач и данных через брокер сообщений, а так же имеет адаптары к множеству брокеров, таких как Redis, RabbitMQ или Amazon SQS.

На роль брокера сообщений был выбран RabbitMQ, который в отличие от Redis имеет более полные гарантии сохранности данных, и в отличие от Amazon SQS является решением с открытым исходным кодом, которое можно запустить на собственной инфраструктуре, не привязываясь к конкретному облачному провайдеру.

Минимальный пример использования Celery с RabbitMQ на языке Python может выглядеть так:

Описываем приложение Celery с функцией сложения двух чисел, помеченной декоратором \texttt{@app.task}:

\begin{lstlisting}
    from celery import Celery

    app = Celery('tasks', broker='amqp://guest@localhost//')

    @app.task
    def add(x, y):
        return x + y
\end{lstlisting}

Запустить сервер обработчик Celery можно так \mintinline{bash}{celery -A tasks worker}.

Вызов функции и получение результата:

\begin{lstlisting}
    from tasks import add
    
    result = add.delay(4, 4)
    print(result.get(timeout=1))
\end{lstlisting}

Celery так же предоставляет возможность различным образом комбинировать задачи, составляя цепочки выполнения заданий. В рамках этой возможности существует несколько примитивов, используя которые можно достичь необходимого результата. Разберем несколько таких примитивов:

\begin{itemize}
    \item group - позволяет выполнить несколько задач параллельно, получив одновременно все результаты
    \item chain - позволяет связать выполнение нескольких последовательных заданий, передавая результаты выполнения по цепочке
    \item chord - комбинирует group и задачу, получающую на вход результаты выполнения группы задач 
\end{itemize}

\begin{lstlisting}
@app.task(
    # игнорируем возвращаемое значение, т.к. результат записывается в БД внутри
    ignore_result=True,
    # используем базовый класс задачи для обработки ошибок
    base=processing.FaceSwapTaskBase,
    # гарантирует что при поломке обработчика задача будет сохранена
    acks_late=True,
    # через 3 часа будет брошено исключение SoftTimeLimitExceeded
    soft_time_limit=10800,
    # еще через 200 секунд принудительно завершает выполнение
    time_limit=11000,
    # пытаемся выполнить задачу заного, если брошено исключение SoftTimeLimitExceeded
    autoretry_for=(SoftTimeLimitExceeded,),
    # максимально делаем 3 попытки обработки задачи
    retry_kwargs={"max_retries": 3},
)
@as_sync
async def execute_face_swap_request(request_id: int): # на вход получаем id задачи из БД
    # выполняем препроцессинг и делим входное видео на сегменты
    segment_tasks = await processing.preprocess_face_swap(request_id)
    signatures = [
        # для каждого сегмента видео:
        # используем примитив chain для связки задачи замены лица и задачи по обработке окончания сегмента
        # при ошибке создаем задачу handle_swap_error
        chain(face_swap.s(asdict(segment)), handle_finished_event.s()).on_error(
            handle_swap_error.si(request_id)
        )
        for segment in segment_tasks
    ]
    # запускаем все задачи по обработке сегментов параллельно
    group(*signatures)()
\end{lstlisting}

\subsection{Клиентское приложение (фронтенд)}

Одно из преимуществ клиент-серверных архитектур - возможность независимой реализации нескольких клиентов к одному серверу. Это позволяет иметь отдельные приложения для различных платформ, таких как ПК, iOS, Android или WEB. Последняя (WEB) выделяется из этого ряда тем, что может работать на всех остальных. Так, любой сайт можно открыть практически на любом доступном устройстве. Поэтому веб является максимально универсальной платформой и избавляет от необходимости разработки других клиентов. Исходя из этого, в качестве первого (и пока единственного) клиентского приложения для реализации был выбран именно WEB.

На данный момент существует множество подходов и технологий реализации веб-приложений, рассмотрение каждого из которых невозможно в рамках данной работы. Мною для разработки был выбран язык Typescript и фреймворк SvelteKit\cite{sveltekit_website}. Это одна из наиболее передовых комбинаций технологий разработки веб-приложений, из плюсов которой можно отметить поддерживаемость, скорость работы и удобство разработки.

Клиент обращается к серверу по протоколу HTTP, используя JSON в качестве формата сообщений.

\subsection{Сервер приложения (бэкенд)}

Основная задача бэкенда в нашей архитектуре - реализация логики работы с различными сущностями и компонентами системы и предоставления внешнего API для клиентов. В качестве архитектурного стиля для реализации API выбран REST\cite{masse2011rest} на базе JSON и HTTP в качестве протокола передачи данных.

Для создания API была выбрана библиотека FastAPI \cite{fastapi_website}. Для работы с базой данных - библотека SQLAlchemy и Alembic в роли движка миграций.

\subsection{СУБД}

СУБД используется для хранения списка пользователей и их аттрибутов, истории запросов на замену лица и данных о состоянии обработки этих запросов, информациии о подписках и правах пользователей и многих других данных.

Основным выборов в области СУБД является использование SQL или NoSQL базы данных. SQL совместимые БД являются де-факто стандартом в области хранения данных. Их особенностью является использования реляционной модели данных\cite{aguidetodb2}. NoSQL появились в ответ на необходимость в горизонтальном масштабировании баз данных при хранении огромных обьемов данных, которое сильно ограничено при использовании SQL. \cite{strauch2011nosql}

Так, основными аргументами для использования NoSQL решений является работа с большими данными и обеспечение высокой доступности при отключении одного из узлов. В данной работе эти проблемы не являются существенными. Так, например, после полугода эсплуатации сервиса в боевом режиме объем хранимых в СУБД данных не превышает 1ГБ, а высокая доступность сервиса ограничивается по большей части другими факторами и не является критичной для бизнеса.

SQL же базы данные предоставляют более существенные для данного проекта преимущества, такие как ACID-транзакции\cite{haerder1983principles}, совместимость и простота миграции между СУБД, типизация моделей данных\cite{ibmsqlvsnosql}.

В итоге, на роль СУБД в разрабатываемом сервиса была выбрана PostgreSQL. От других подобных решений она отличается полной бесплатностью и открытым исходным кодом, огромным сообществом, множеством возможностей и дополнений, работой "из коробки" с практически любыми языками и библиотеками.

В пользу PostgreSQL так же играет возможность аренды преднастроенного и полностью управляемого сервера БД у большинства облачных провайдеров, в том числе Microsoft Azure\cite{azure_postgresql}. Облачные провайдеры гарантируют определенный уровень доступности сервера, предоставляют автоматическое резервное копирование и обновление сервера, а так же легкое вертикальное масштабирование и мониторинг.

При работе с БД было решено использовать ORM \cite{keith2009object} фреймворк SQLAlchemy и систему миграций Alembic для ЯП Python. Это позволяет отказаться от написания запросов на чистом SQL, таким образом избежав привязки к конкретному диалекту SQL и упростить возможную миграцию на другую СУБД. 

